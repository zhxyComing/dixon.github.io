<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content>
  <meta name="author" content="Dixon Xu">
  <!-- Open Graph Data -->
  <meta property="og:title" content="从零开始的Android插件化">
  <meta property="og:description" content>
  <meta property="og:site_name" content="Dixon&#39;s blog">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://yoursite.com">
  
    <link rel="alternate" href="/atom.xml" title="Dixon&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>Dixon's blog</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/images/cover7.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">从零开始的Android插件化</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/zhxyComing">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:1198097193@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Dixon Xu</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-05-11</span>
            <span class="time">20:47:46</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/Android/">Android</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/Android插件化/">#Android插件化</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>如何使用宿主 app 直接加载运行放在 sd 卡下的 apk。<br><a id="more"></a></p>
<p>从零开始的Android插件化</p>
<p>关于插件化有很多知识点可讲，市面上也有很多成熟的第三方库，这篇 Blog 不是讲解这些第三方库的使用，而是探索如何从零开始使用”反射”、”Hook”等知识点，在不安装插件 apk 的情况下，实现自己的宿主 App 加载放在 sd 卡的插件 apk，从而一窥 Android 插件化的原理。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Android 开发中经常有这样的情况：模块化不清晰、方法数超限、想在不重新安装 App 的情况下增加新的模块，基于这样的需求，结合 Android DexClassLoader 可以加载 dex 文件以及包含 dex 的压缩文件（apk 和 jar）的特点，催生出了 Android 插件化技术。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>1.DexClassLoader 可以加载外部 dex 文件以及包含 dex 的压缩文件（apk 和 jar）。<br>2.熟知 Activity 的启动流程，利用 Hook 技术启动外部 dex 文件中的 Activity。</p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="实现流程图"><a href="#实现流程图" class="headerlink" title="实现流程图"></a>实现流程图</h3><p><img src="/2019/05/11/从零开始的Android插件化/流程概览.png" alt="流程概览.png"></p>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>我们知道 Activity 必须在 AndroidManifest 中配置才能正常启动，否则会报 ActivityNotFound 异常，而外部插件 apk 中的 Activity 肯定是无法在宿主 App 中配置的，这样因为找不到相关配置 startActivity 就会 crash。为了方便理解，我们先去实现如何在 AndroidManifest 没有配置 TestActivity 的情况下，启动宿主 App 的 TestActivity（注意 TestActivity 是宿主 App 而不是外部 apk 或 dex 文件的）。</p>
<h4 id="步骤1：绕过-AndroidManifest-检测"><a href="#步骤1：绕过-AndroidManifest-检测" class="headerlink" title="步骤1：绕过 AndroidManifest 检测"></a>步骤1：绕过 AndroidManifest 检测</h4><p>Activity 启动过程中是应用程序进程与 AMS 频繁交互的过程。AMS 处于系统 SystemServer 进程中，我们无法修改，所以只能 Hook 应用程序进程部分，以实现需求。</p>
<p>这里采用占位策略，原理是提前在 AndroidManifest 中配置一个占位页面<code>&lt;activity android:name=&quot;.SubActivity&quot; /&gt;</code>，在应用程序进程将 targetIntent 传给 AMS 之前，替换 targetIntent 为该占位 intent，之后在 AMS 传回应用程序进程之后、应用程序进程调用 intent 启动 Activity 之前，将占位 intent 再次替换为 targetIntent 即可。下面具体实现：</p>
<p>首先实现工具类 <code>FieldUtil</code>，方便后续反射操作：</p>
<p><strong><1></1></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Field对应的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getField</span><span class="params">(Class clazz, Object target, String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field field = clazz.getDeclaredField(name);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> field.get(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Field</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title">getField</span><span class="params">(Class clazz, String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field field = clazz.getDeclaredField(name);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给Field赋值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setField</span><span class="params">(Class clazz, Object target, String name, Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field field = clazz.getDeclaredField(name);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(target, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么应用程序进程是什么时候将 intent 传给 AMS 的呢？通过层层查找 startActivity 源码，最终定位在下面的源码上：</p>
<p>android.app.Instrumentation</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="keyword">int</span> result = ActivityManager.getService()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);<span class="comment">//1.</span></span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IActivityManager 是 AMS 在客户端的代理类，通过它与 AMS 跨进城通信，看下注释1处 ActivityManagerService 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IActivityManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IActivityManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">        <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                <span class="keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                <span class="keyword">return</span> am;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>这里用到 Singleton 实现单例，接着研究 Singleton 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T mInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mInstance = create();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是 Hook 点找到了：利用反射，替换 Singleton<iactivitymanager> 中的 IActivityManager 为自己的代理类，即可插入替换 targetIntent 的代码。下面是具体实现：</iactivitymanager></p>
<p>首先创建自己的代理类，用于替换 targetIntent 为占位 intent 以绕过检测，这里使用动态代理：</p>
<p><strong><2></2></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IActivityManagerProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object mActivityManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"IActivityManagerProxy"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IActivityManagerProxy</span><span class="params">(Object activityManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mActivityManager = activityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//执行原方法之前，先执行代理方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"startActivity"</span>.equals(method.getName())) &#123;</span><br><span class="line">            Intent intent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//找到intent参数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> Intent) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            intent = (Intent) args[index];</span><br><span class="line">            Intent subIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">            String packageName = <span class="string">"com.app.dixon.studyplug"</span>;<span class="comment">//1.替换 TargetIntent 的参数</span></span><br><span class="line">            subIntent.setClassName(packageName, packageName + <span class="string">".SubActivity"</span>);<span class="comment">//替换 TargetIntent 的参数</span></span><br><span class="line">            subIntent.putExtra(HookHelper.TARGET_INTENT, intent);<span class="comment">//2.</span></span><br><span class="line">            args[index] = subIntent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(mActivityManager, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释1处，创建占位 intent 用于替换传给 AMS 的 targetIntent；<br>注释2处，将 targetIntent 存储起来，方便后续拿出启动。</p>
<p>创建完代理类，就可以 Hook 替换 IActivityManager 了，由于 Singleton\<iactivitymanager> 是静态的，所以替换整个进程生效。</iactivitymanager></p>
<p>创建 HookHelper 类，Hook Singleton\<iactivitymanager>.mInstance：</iactivitymanager></p>
<p><strong><3></3></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TARGET_INTENT = <span class="string">"target_intent"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TARGET_INTENT_NAME = <span class="string">"target_intent_name"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"HOOK"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hook IActivityManager 由于IActivityManagerSingleton是静态成员变量 所以是全局Hook</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookAMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object defaultSingleton = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">26</span>) &#123;<span class="comment">//版本号 &gt; 8.0</span></span><br><span class="line">            Class&lt;?&gt; activityManagerClazz = Class.forName(<span class="string">"android.app.ActivityManager"</span>);</span><br><span class="line">            <span class="comment">//获取Singleton&lt;IActivityManager&gt;</span></span><br><span class="line">            defaultSingleton = FieldUtil.getField(activityManagerClazz, <span class="keyword">null</span>, <span class="string">"IActivityManagerSingleton"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class&lt;?&gt; activityManagerNativeClazz = Class.forName(<span class="string">"android.app.ActivityManagerNative"</span>);</span><br><span class="line">            <span class="comment">//获取ActivityManagerNative中的gDefault字段</span></span><br><span class="line">            defaultSingleton = FieldUtil.getField(activityManagerNativeClazz, <span class="keyword">null</span>, <span class="string">"gDefault"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//替换Singleton中的值</span></span><br><span class="line">        <span class="comment">//1.获取class，找到其属性</span></span><br><span class="line">        Class&lt;?&gt; singletonClazz = Class.forName(<span class="string">"android.util.Singleton"</span>);</span><br><span class="line">        Field mInstanceField = FieldUtil.getField(singletonClazz, <span class="string">"mInstance"</span>);</span><br><span class="line">        <span class="comment">//2.获取IActivityManager</span></span><br><span class="line">        Object iActivityManager = mInstanceField.get(defaultSingleton);</span><br><span class="line">        <span class="comment">//3.获取IActivityManager的Proxy代理类</span></span><br><span class="line">        Class&lt;?&gt; iActivityManagerClazz = Class.forName(<span class="string">"android.app.IActivityManager"</span>); <span class="comment">//IActivityManager的全路径</span></span><br><span class="line">        Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class&lt;?&gt;[]&#123;iActivityManagerClazz&#125;,</span><br><span class="line">                <span class="keyword">new</span> IActivityManagerProxy(iActivityManager));</span><br><span class="line">        <span class="comment">//4.替换</span></span><br><span class="line">        mInstanceField.set(defaultSingleton, proxy);</span><br><span class="line">        Log.e(TAG, <span class="string">"Hook Finish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致步骤是：获取 <code>android.app.ActivityManager</code> 中的静态成员变量 Singleton\<iactivitymanager>，获取其 mInstance 属性，创建动态代理类 IActivityManagerProxy，替换 mInstance。详情已经在上述注释中标明。</iactivitymanager></p>
<p>之后在 Application 中调用：</p>
<p><strong><4></4></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Application application;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">        application = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HookHelper.hookAMS();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.e(HookHelper.TAG, <span class="string">"The reason for the error is "</span> + e.toString());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述操作，AMS 遍历 AndroidManifest 时检测的是占位 intent 而不是 targetIntent，故不会抛出 ActivityNotFound 的异常。</p>
<h4 id="步骤2：还原-targetIntent"><a href="#步骤2：还原-targetIntent" class="headerlink" title="步骤2：还原 targetIntent"></a>步骤2：还原 targetIntent</h4><p>为了绕过检测我们将 targetIntent 临时替换为了占位 intent，相应的，在 AMS 允许应用程序进程启动 Activity 时，我们应当将占位 intent 还原为 targetIntent。</p>
<p>那么什么时间点还原合适呢？</p>
<p>我们知道 ActivityThread 作为应用程序进程的主线程，在很多方面起了关键的作用，其中包括 Activity 的启动。其中 <code>handleLaunchActivity</code> 中有一行源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 r 为 ActivityClientRecord 类型，它有个 Intent 类型的成员变量名为 <code>intent</code>，这个 <code>intent</code> 就是上面 AMS 传回给应用程序进程的 intent。</p>
<p>回到该方法的上一步，看下它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</span><br><span class="line">                    <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line"></span><br><span class="line">                    r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                            r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">                    handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">"LAUNCH_ACTIVITY"</span>);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>ActivityThread 通过特殊的 Handler ：H 来分发 AMS 发来的各种事件，其中 Handler 的 dispatchMessage 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合上述源码，我们知道了 msg.obj 中包含了之前了占位 intent，所以我们只需要将 H 的 mCallback 赋值为自定义的 Callback，并在 Callback.handleMessage 中做替换 intent 的操作，之后再重新手动调用 <code>H.handleMessage(msg);</code> 即可。具体实现如下：</p>
<p>首先实现自定义的 HCallback 类，在其中做替换 intent 操作：</p>
<p><strong><5></5></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HCallback</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAUNCH_ACTIVITY = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HCallback</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        mHandler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行原handleMessage方法之前执行Hook的HandleMessage</span></span><br><span class="line">        <span class="keyword">if</span> (msg.what == LAUNCH_ACTIVITY) &#123;</span><br><span class="line">            Object r = msg.obj;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取之前消息中的真实Intent</span></span><br><span class="line">                Intent intent = (Intent) FieldUtil.getField(r.getClass(), r, <span class="string">"intent"</span>);</span><br><span class="line">                Intent target = intent.getParcelableExtra(HookHelper.TARGET_INTENT);</span><br><span class="line">                <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//替换</span></span><br><span class="line">                    FieldUtil.setField(r.getClass(), r, <span class="string">"intent"</span>, target);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//手动重新调用handleMessage</span></span><br><span class="line">        mHandler.handleMessage(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来需要把我们上述自定义的 HCallback 赋值给 ActivityThread.H.mCallback，在 HookHelper 类中添加如下方法：</p>
<p><strong><6></6></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标是对 ActivityThread 的 mH.callback 进行替换，而 ActivityThread 单进程只有一个，所以是全局替换</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//获取ActivityThread.mH</span></span><br><span class="line">    Class activityThreadClazz = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">    Object currentActivityThread = FieldUtil.getField(activityThreadClazz, <span class="keyword">null</span>, <span class="string">"sCurrentActivityThread"</span>);</span><br><span class="line">    Field mHField = FieldUtil.getField(activityThreadClazz, <span class="string">"mH"</span>);</span><br><span class="line">    Handler mH = (Handler) mHField.get(currentActivityThread);</span><br><span class="line">    <span class="comment">//替换H.mCallback</span></span><br><span class="line">    FieldUtil.setField(Handler.class, mH, <span class="string">"mCallback"</span>, <span class="keyword">new</span> HCallback(mH));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityThread 单进程只有一个，可以通过它的静态成员变量 <code>sCurrentActivityThread</code> 获得，获取到之后将 HCallback 赋值给 mH.mCallback 即可。</p>
<p>最后记得在上述 Application 中调用：</p>
<p><strong><4>改</4></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Application application;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">        application = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HookHelper.hookAMS();</span><br><span class="line">            HookHelper.hookHandler();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.e(HookHelper.TAG, <span class="string">"The reason for the error is "</span> + e.toString());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述俩大步骤，我们在项目中创建任意 Activity，然后删除掉它在 AndroidManifest 中的配置，然后通过下面代码也可以正常启动，如示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, TestActivity.class));</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/11/从零开始的Android插件化/AndroidManifest截图.png" alt="AndroidManifest截图.png"></p>
<p>那么有一个问题：这样启动的 Activity 可以正常遵从 AMS 对生命周期的管理吗？<br>答案是肯定，AMS 通知应用程序进程创建 Activity 之后是通过 Token 进行后续生命周期通信的，而 Token 依赖于真实创建的 TargetActivity，所以 TargetActivity 是有生命周期的。有兴趣的可以单独研究源码，这里不再深入探讨。</p>
<h4 id="步骤3：加载插件-dex"><a href="#步骤3：加载插件-dex" class="headerlink" title="步骤3：加载插件 dex"></a>步骤3：加载插件 dex</h4><p>步骤1、2实现了不配置 AndroidManifest 也能正常启动 Activity，但我们的终极目标是启动外部 apk，首先就需要把外部 apk 加载进来。</p>
<p>使用 Android 提供的 <code>DexClassLoader</code> 可以加载外部 dex 文件或加载包含 dex 的文件，如 apk、jar 等。这里我创建了 <code>AppClassLoaderHelper</code> 类，用于获取加载了外部 apk 的 <code>ClassLoader</code>。源码如下：</p>
<p><strong><7></7></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoaderHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, ClassLoader&gt; classLoaderCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Resources&gt; resourceCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"AppClassLoaderHelper"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 得到对应插件的ClassLoader对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getDexClassLoader</span><span class="params">(Context context, String appPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (classLoaderCache.containsKey(appPath)) &#123;</span><br><span class="line">            <span class="keyword">return</span> classLoaderCache.get(appPath);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(TAG, <span class="string">"path is "</span> + appPath);</span><br><span class="line">        String dexOutFilePath = context.getCacheDir().getAbsolutePath();</span><br><span class="line">        Log.e(TAG, <span class="string">"dexOutFilePath is "</span> + dexOutFilePath);</span><br><span class="line">        DexClassLoader classLoader = <span class="keyword">new</span> DexClassLoader(appPath, dexOutFilePath, <span class="keyword">null</span>, context.getClassLoader());</span><br><span class="line">        classLoaderCache.put(appPath, classLoader);</span><br><span class="line">        <span class="keyword">return</span> classLoader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>利用 DexClassLoader 将外部的 apk 加载了进来，他的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent)</span><br></pre></td></tr></table></figure>
<p>四个参数分别是：<br>1.dexPath 的全路径。<br>2.optimizedDirectory：加载的 dex 存放的目录。<br>3.librarySearchPath：library 库路径。<br>4.parent：父类 ClassLoader，双亲委托不是本文重点，有兴趣可以 Google 了解。</p>
<p>这里我新建了一个项目，用于生成插件 apk。项目很简单，只有一个空页面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成 apk 之后将该文件存放到手机 sd 卡根目录下：<code>/storage/emulated/0/app-debug.apk</code>。</p>
<p>因为我放的位置特殊，所以需要在 AndroidManifest 中配置读取 sd 卡的权限：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>Android 6.0 及以上还需要动态获取，所以假如报 ClassNotFound 异常，检查你的 App 是否真的有 sd 卡读写权限。</p>
<p>之后就可以尝试在宿主 App 中启动我们的目标页面了：</p>
<p><strong><8></8></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startOtherApp</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ClassLoader loader = AppClassLoaderHelper.getDexClassLoader(MyApplication.application, <span class="string">"/storage/emulated/0/app-debug.apk"</span>);</span><br><span class="line">        Class&lt;?&gt; targetClass = loader.loadClass(<span class="string">"com.app.dixon.plugin.MainActivity"</span>);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, targetClass);</span><br><span class="line">        intent.putExtra(HookHelper.TARGET_INTENT_NAME, intent.getComponent().getClassName());</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">//classNotFound 注意有可能是权限问题</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我通过加载了外部 apk 文件的 ClassLoader 去获取目标页面 <code>com.app.dixon.plugin.MainActivity</code> 的 Class，之后创建 intent，并赋值 <code>HookHelper.TARGET_INTENT_NAME</code> 用于标记这是一个插件 apk 的页面，便于后续识别。最后通过 <code>startActivity(intent)</code> 启动。</p>
<p>运行，果然 Crash 了，报错如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: Unable to instantiate activity ComponentInfo&#123;com.app.dixon.studyplug/com.app.dixon.plugin.MainActivity&#125;: java.lang.ClassNotFoundException: Didn<span class="string">'t find class "com.app.dixon.plugin.MainActivity" on path: DexPathList[[zip file "/data/app/com.app.dixon.studyplug-RqW1yxJOWJ4JvMTrVZogWA==/base.apk"],nativeLibraryDirectories=[/data/app/com.app.dixon.studyplug-RqW1yxJOWJ4JvMTrVZogWA==/lib/arm64, /system/lib64, /vendor/lib64]]</span></span><br></pre></td></tr></table></figure>
<p>这是为什么呢？仔细分析，可以看出：</p>
<p>我们使用 DexClassLoader 获取到的插件 Activity 的 Class 只是用于创建 Intent，在上述步骤2中、真正 new Activity 时，使用的 ClassLoader 仍然是宿主 App 的 ClassLoader，宿主 App 的 ClassLoader 从来没有加载过外部插件 apk，当然会报 ClassNotFoundException。</p>
<h4 id="步骤4：替换插件-Activity-ClassLoader"><a href="#步骤4：替换插件-Activity-ClassLoader" class="headerlink" title="步骤4：替换插件 Activity ClassLoader"></a>步骤4：替换插件 Activity ClassLoader</h4><p>经过上述分析，我们需要在加载插件 apk 时，将宿主 App 的 ClassLoader 替换为自定义的 DexClassLoader。</p>
<p>替换时机一定和 <code>new Activity</code> 的时机有关，上面我们说到 Activity 示例是 <code>performLaunchActivity</code> 方法返回的，看下它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        Activity activity = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Unable to instantiate activity "</span> + component</span><br><span class="line">                    + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>经常做单元测试的同学可能对 Instrumentation 这个类不会陌生，它是 ActivityThread 的成员变量之一，用于转交执行 Activity 的一些关键方法。这里可以看到 Activity 就是它创建的，它的 newActivity 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">            ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Activity)cl.loadClass(className).newInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>第一个参数 cl 就是 Activity 对应的 ClassLoader，所以这儿的做法是，替换 ActivityThread.mInstrumentation，重写它的 newActivity 方法，使其在启动插件 apk 时，加载自定义的 DexClassLoader。下面是具体实现：</p>
<p><strong><9></9></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentationProxy</span> <span class="keyword">extends</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className, Intent intent)</span> <span class="keyword">throws</span> InstantiationException,</span></span><br><span class="line"><span class="function">            IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">        String intentName = intent.getStringExtra(HookHelper.TARGET_INTENT_NAME);</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(intentName)) &#123;<span class="comment">//1.</span></span><br><span class="line">            <span class="comment">//通过自定义的classLoader加载目标类</span></span><br><span class="line">            Activity activity = <span class="keyword">super</span>.newActivity(AppClassLoaderHelper.getDexClassLoader(MyApplication.application, <span class="string">"/storage/emulated/0/app-debug.apk"</span>), intentName, intent);</span><br><span class="line">            <span class="keyword">return</span> activity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.newActivity(cl, className, intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释1处，前面我们给 intent 赋值了 HookHelper.TARGET_INTENT_NAME，这里我们利用该标识判断：如果是插件 apk，就使用自定义 DexClassLoader，否则还是走宿主 ClassLoader。</p>
<blockquote>
<p><code>TARGET_INTENT_NAME</code>意味着插件 apk 也需要传此标识，这对插件的独立开发是不友好的。<br>实际上有更好的实现方式，不需要传递标识也能识别是否是插件 apk 中的 class，详情参考 Github 源码。</p>
</blockquote>
<p>接下来就是想办法把 <code>ActivityThread.mInstrumention</code> 替换为上述 <code>InstrumentationProxy</code>，在 HookHelper 中增加方法：</p>
<p><strong><10></10></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hook newActivity 使其不加载系统、而加载自定义ClassLoader中的Activity</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookInstrumentation</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class activityThreadClazz = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">    Object currentActivityThread = FieldUtil.getField(activityThreadClazz, <span class="keyword">null</span>, <span class="string">"sCurrentActivityThread"</span>);</span><br><span class="line">    FieldUtil.setField(activityThreadClazz, currentActivityThread, <span class="string">"mInstrumentation"</span>, <span class="keyword">new</span> InstrumentationProxy());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记得在 Application 中调用：</p>
<p><strong><4>再改</4></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Application application;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">        application = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HookHelper.hookAMS();</span><br><span class="line">            HookHelper.hookHandler();</span><br><span class="line">            HookHelper.hookInstrumentation();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.e(HookHelper.TAG, <span class="string">"The reason for the error is "</span> + e.toString());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后运行，不再报 ClassNotFound 的异常了，说明插件 Activity 的 Class 正常找到，且该页面能正常创建了。</p>
<p>但是，仍然发生了 Crash，这次的异常是资源找不到。</p>
<p>仔细想想，我们在加载外部插件 apk 的时候，从头到尾都只加载了 Class，没有加载其资源，插件 Activity 使用的 mResources 是宿主 App 的，资源当然会找不到！</p>
<h4 id="步骤5：替换插件-Activity-mResources"><a href="#步骤5：替换插件-Activity-mResources" class="headerlink" title="步骤5：替换插件 Activity mResources"></a>步骤5：替换插件 Activity mResources</h4><p>在 AppClassLoaderHelper 中增加如下方法加载插件资源并获取其 Resources，关于资源加载的原理这里不再深入探讨，直接看下面源码：</p>
<p><strong><11></11></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> appPath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 得到对应插件的Resource对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resources <span class="title">getPluginResources</span><span class="params">(Context context, String appPath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resourceCache.containsKey(appPath)) &#123;</span><br><span class="line">        <span class="keyword">return</span> resourceCache.get(appPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AssetManager assetManager = AssetManager.class.newInstance();</span><br><span class="line">        <span class="comment">//反射调用方法addAssetPath(String path)</span></span><br><span class="line">        Method addAssetPath = assetManager.getClass().getMethod(<span class="string">"addAssetPath"</span>, String.class);</span><br><span class="line">        <span class="comment">//将未安装的Apk文件的添加进AssetManager中,第二个参数是apk的路径</span></span><br><span class="line">        addAssetPath.invoke(assetManager, appPath);</span><br><span class="line">        Resources superRes = context.getResources();</span><br><span class="line">        Resources mResources = <span class="keyword">new</span> Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());</span><br><span class="line">        resourceCache.put(appPath, mResources);</span><br><span class="line">        <span class="keyword">return</span> mResources;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mResources</code> 是 <code>ContextThemeWrapper</code> 的成员变量之一，而 Activity 继承自 <code>ContextThemeWrapper</code>，所以只需要将插件 Activity 的 mResources 重新赋值为上述 <code>getPluginResources</code> 返回的 resources 即可。还记得 <code>InstrumentationProxy</code>吗？我们刚才在那里 <code>new Activity</code>，所以只需要紧随其后更换 mResources 即可。</p>
<p><strong><9>改</9></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentationProxy</span> <span class="keyword">extends</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className, Intent intent)</span> <span class="keyword">throws</span> InstantiationException,</span></span><br><span class="line"><span class="function">            IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">        String intentName = intent.getStringExtra(HookHelper.TARGET_INTENT_NAME);</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(intentName)) &#123;</span><br><span class="line">            <span class="comment">//通过自定义的classLoader加载目标类</span></span><br><span class="line">            Activity activity = <span class="keyword">super</span>.newActivity(AppClassLoaderHelper.getDexClassLoader(MyApplication.application, <span class="string">"/storage/emulated/0/app-debug.apk"</span>), intentName, intent);</span><br><span class="line">            <span class="comment">//新增：</span></span><br><span class="line">            <span class="comment">//通过自定义的resources加载目标资源</span></span><br><span class="line">            <span class="comment">//这样TargetActivity使用的就是其Apk本身的资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FieldUtil.setField(ContextThemeWrapper.class, activity, <span class="string">"mResources"</span>, AppClassLoaderHelper.getPluginResources(MyApplication.application, <span class="string">"/storage/emulated/0/app-debug.apk"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> activity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.newActivity(cl, className, intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里似乎没什么问题了，然后点击启动插件 apk，boom～crash</p>
<p>ClassLoader 正常加载了，资源也映射正确了，为什么还是 crash 了呢？</p>
<p>查找原因，crash 说资源仍然找不到，资源号是 0x7xxxxx。通过查找该资源，发现是宿主 App 的 R.mipmap.ic_launcher，就是 Android app 默认的图标。插件 Activity 使用的资源是自己 apk 的，当它使用宿主 app 的 id 去查找资源当然会找不到了。</p>
<p>分析到这里，我明白当前的错误也许和插件 app 使用的 AppTheme 有关系，也许是 TopBar 不完全由 Activity 掌控，导致 TopBar 的资源 id 仍然使用宿主 App 的。为了演示方便（其实是懒），我这里暂时将插件 apk 的目标页面设置成了没有 TopBar 的主题：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"AppTheme"</span> parent=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><br><span class="line">    &lt;!-- Customize your theme here. --&gt;</span><br><span class="line">    &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该问题后续已修复。</p>
</blockquote>
<p>果然，再次启动插件 apk，终于成功了！</p>
<h4 id="步骤6：后续实践"><a href="#步骤6：后续实践" class="headerlink" title="步骤6：后续实践"></a>步骤6：后续实践</h4><p>在插件 apk 页面里，我首先放了张图，资源能正确加载，如图：</p>
<p><img src="/2019/05/11/从零开始的Android插件化/效果图.png" alt="效果图.png set-w300"></p>
<p>随后我在插件 apk 里又新建了一个 OtherActivity，然后插件 MainActivity 通过下面代码启动 OtherActivity：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,OtherActivity.class);</span><br><span class="line">    intent.putExtra(<span class="string">"target_intent_name"</span>, intent.getComponent().getClassName());</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>target_intent_name</code> 就是我们之前识别插件页面的标识，有了这个标识，才会给当前 Activity 加载正确的 ClassLoader 和 Resources。这里测试插件 A 页面启动插件 B 页面没有问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>插件化涉及到的内容很多，本文只是对插件化实现的一个从零开始的探索，原理基于此，相信今后扩展、完善、源码探索也就有据可循。</p>
<p><a href="https://github.com/zhxyComing/PlugDemo" target="_blank" rel="noopener">Github 源码地址</a>，后续会不断完善。</p>
<p>本人能力有限，步骤1、2部分参考了 Android 进阶揭秘一书，错误之处还请指出。</p>
<p>[TOC]</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        </p><p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

